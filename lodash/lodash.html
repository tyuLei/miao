<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<script>
  var tyulei = {
    isNull: function (val) {
      if (val === null) {
        return true
      } else {
        return false
      }
    },
    isNaN: function (val) {
      if (val !== val) {
        return true
      } else {
        return false
      }
    },
    /**
     * 将一个数组划分为指定长度的多个数组
     * @param {array} 输入的数组
     * @param {size} 要切分的数组长度
     * @returns {arrays} 返回切分后的数组，如果不能均匀切分，则多余的放到最后一项
    */
    chunk: function (ary, size = 1) {
      var aryNew = []
      var num = 0
      var flog = 0
      aryNew[0] = []
      aryNew[0][0] = ary[0]
      for (let i = 1; i < ary.length; i++) {
        if (i % size == 0) {
          flog++
          aryNew[flog] = []
        }
        aryNew[flog][i % size] = ary[i]
      }
      return aryNew
    },
    difference: function (ary, ...values) {
      values = [].concat(...values)
      ary = ary.filter(x => !values.includes(x))
      return ary
    },
    drop: function (ary, n = 1) {
      let aryNew = []
      for (let i = n; i < ary.length; i++) {
        aryNew.push(ary[i])
      }
      return aryNew
    },
    indexOf: function (ary, value, fromindex = 0) {
      if (fromindex < 0) {
        fromindex = ary.length + fromindex
      }
      for (let i = fromindex; i < ary.length; i++) {
        if (ary[i] == value) {
          return i
        }
      }
      return -1
    },
    initial: function (ary) {
      let aryNew = []
      for (let i = 0; i < ary.length - 1; i++) {
        aryNew.push(ary[i])
      }
      return aryNew
    },
    intersection: function (...ary) {
      let aryNew = []
      let count = 0
      let obj = {}
      for (let i = 0; i < arguments.length; i++) {
        for (let j = 0; j < arguments[j].length; j++) {
          aryNew.push(arguments[i][j])
        }
        for (let i = 0; i < aryNew.length; i++) {
          if (aryNew[i]) {

          }
        }

      }

    },


    lastIndexOf: function (ary, value, fromIndex = ary.length - 1) {
      for (let i = fromIndex; i >= 0; i--) {
        if (ary[i] == value) {
          return i
        }
      }
      return -1
    },
    fill: function (ary, value, start = 0, end = ary.length) {
      let aryNew = []
      for (let i = 0; i < ary.length; i++) {
        if (i >= start && i < end) {
          aryNew.push(value)
        } else {
          aryNew.push(ary[i])
        }
      }
      return aryNew
    },
    pull: function (ary, ...values) {
      values = [].concat(...values)
      return ary = ary.filter(x => !values.includes(x))
    },
    pullAll: function (ary1, ary2) {
      return ary1 = ary1.filter(x => !ary2.includes(x))
    },
    pullAt: function (ary) {
      let aryNew = []
      for (let i = 0; i < ary.length; i++) {
        for (let j = 1; j < arguments.length; j++) {
          if (i == arguments[j]) {
            aryNew.push(ary[i])
          }
        }
      }
      tyulei.pullAll(ary, aryNew)

      return aryNew
    },
    sortIndexOf: function (ary, value) {
      for (let i = 0; i < ary.length; i++) {
        if (ary[i] == value && ary[i + 1] !== value) {
          return i
        }
      }
      return -1
    },
    takeRight: function (ary, number = 1) {
      let aryNew = []
      for (let i = ary.length - number; i < ary.length; i--) {
        aryNew.push(ary[i])
      }
      return aryNew
    },
    nuiq: function (ary) {
      let obj = {}
      let aryNew = []
      for (let i = 0; i < ary.length; i++) {
        if (obj[ary[i]] == undefined) {
          aryNew.push(ary[i])
          obj[ary[i]] = i
        }
      }
      return aryNew
    },
    unzip: function (ary) {
      let aryNew = []
      let length = []
      //找出输入二维数组中的最长数组
      for (let i = 0; i < ary.length; i++) {
        length.push(ary[i].length)
      }
      //创建一个新的空的二维数组
      for (let i = 0; i < Math.max(...length); i++) {
        aryNew.push([])
      }
      //把原来的二维数组里的值按顺序装到新的数组
      for (let i = 0; i < aryNew.length; i++) {
        for (let j = 0; j < ary.length; j++) {
          aryNew[i].push(ary[j][i])
        }
      }
      return aryNew
    },
    /*without: function (ary, values) {
      let obj = {}
      let aryNew = []
      for (let i = 1; i < arguments.length; i++) {
        obj[arguments[i]] = i
      }
      for (let i = 0; i < ary.length; i++) {
        if (obj[ary[i]] == undefined) {
          aryNew.push(ary[i])
        }
      }
      return aryNew
    },*/
    without: function (ary, ...values) {
      let aryNew = []
      values = [].concat(...values)
      for (let i = 0; i < ary.length; i++) {
        if (values.indexOf(ary[i]) == -1) {
          aryNew.push(ary[i])
        }
      }
      return aryNew
    },
    xor: function (...values) {
      let ary = []
      for (let i = 0; i < values.length; i++) {
        for (let j = 0; j < values[i].length; j++) { //遍历values的数值
          if (!ary.includes(values[i][j])) { //如果ary内不存在该值，就push进去
            ary.push(values[i][j])
          } else {
            ary.splice(ary.indexOf(values[i][j]), 1)  //如果存在，就删除
          }
        }
      }
      return ary

    },
    defaults: function (obj) {
      let objNew = {}
      for (let i = 0; i < arguments.length; i++) {
        for (var prop in arguments[i]) {
          if (objNew[prop] == undefined) {
            objNew[prop] = arguments[i][prop]
          }
        }
      }
      return objNew
    },
    omit: function (obj, props) {
      let objNew = {}
      for (let i = 0; i < props.length; i++) {
        for (let prop in obj) {
          if (prop !== props[i]) {
            objNew[prop] = obj[prop]
          }
        }
      }
      return objNew
    },
    zipObject: function (ary1, ary2) {
      let obj = {}
      let len = Math.max(ary1.length, ary2.length)
      for (let i = 0; i < len; i++) {
        obj[ary1[i]] = ary2[i]
      }
      return obj
    },
    isNaN: function (val) {
      if (typeof val == 'object') {
        return val.toString() == 'NaN'
      }
      return val !== val
    },
    concat: function (...arys) {
      var aryNew = []
      for (var i = 0; i < arys.length; i++) {
        if (Array.isArray(arys[i])) {
          for (var j = 0; j < arys[i].length; j++) {
            aryNew.push(arys[i][j])
          }
        } else {
          aryNew.push(arys[i])
        }
      }
      return aryNew
    },
    pullAt: function (ary1, ary2) {
      let aryNew = []
      let aryRe = []
      for (let i = 0; i < ary1.length; i++) {
        if (ary2.includes(i)) {
          aryNew.push(ary1[i])
        } else {
          aryRe.push(ary1[i])
        }
      }
      for (let i = 0; i < aryRe.length; i++) {
        ary1[i] = aryRe[i]
      }
      ary1.splice(ary1.length - ary2.length, ary2.length)
      return aryNew
    },



  }
</script>

<body>
  <em>
    chunk,compact
    concat
    difference
    drop
    fill
    find
    first/head
    flatten
    indexOf
    initial
    intersection
    join
    last
    lastIndexOf
    nth
    pull
    pullAll
    pullAt
    remove
    reverse
    slice
    sortedIndex
    sortedIndexOf
    tail
    take
    takeRight
    union
    uniq
    unzip
    without
    xor
    zip
    zipObject

    includes
    sample
    sampleSize
    shuffle
    size
    eq,gt,gte
    lt,lte
    add,ceil
    divide
    floor
    max
    mean
    min
    multiply
    round
    substract
    sum
    at
    defaults
    get
    set
    has
    hasIn
    invert
    keys
    assign
    omit



    pick
    values
    camelCase
    capitalize
    deburr

    endsWith
    escape
    kebabCase
    lowerCase
    lowerFirst
    pad
    padEnd
    padStart
    parseInt
    repeat
    replace
    snakeCase
    split
    startCase
    startsWith
    trim
    trimEnd
    trimStart
    truncate
    unescape
    upperCase
    upperFirst
    words
    range
  </em>
</body>

</html>