<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<script>
  var tyulei = {
    isNull: function (val) {
      if (val === null) {
        return true
      } else {
        return false
      }
    },
    isNaN: function (val) {
      if (val !== val) {
        return true
      } else {
        return false
      }
    },
    chunk: function (ary, size = 1) {
      if (size <= 1) {
        return ary
      }
      var aryNew = []
      var count = 0
      var number = 0
      for (var j = 0; j < size; j++) {
        aryNew[j] = []
      }

      for (var i = 0; i < ary.length; i++) {

        aryNew[number].push(ary[i])
        count++
        if (count == Math.ceil(ary.length / size)) {
          number++
        }
      }
      return aryNew
    },
    difference: function (ary1, ary2) {
      for (let i = 0; i < ary1.length; i++) {
        for (let j = 0; j < ary2.length; j++) {
          if (ary1[i] == ary[j]) {
            ary1.splice(i, 1)
          }
        }
      }
      return ary1
    },
    drop: function (ary, n = 1) {
      let aryNew = []
      for (let i = n; i < ary.length; i++) {
        aryNew.push(ary[i])
      }
      return aryNew
    },
    indexOf: function (ary, value, fromindex = 0) {
      if (fromindex < 0) {
        fromindex = ary.length + fromindex
      }
      for (let i = fromindex; i < ary.length; i++) {
        if (ary[i] == value) {
          return i
        }
      }
      return -1
    },
    initial: function (ary) {
      let aryNew = []
      for (let i = 0; i < ary.length - 1; i++) {
        aryNew.push(ary[i])
      }
      return aryNew
    },
    intersection: function (...ary) {
      let aryNew = []
      let count = 0
      let obj = {}
      for (let i = 0; i < arguments.length; i++) {
        for (let j = 0; j < arguments[j].length; j++) {
          aryNew.push(arguments[i][j])
        }
        for (let i = 0; i < aryNew.length; i++) {
          if (aryNew[i]) {

          }
        }

      }

    },


    lastIndexOf: function (ary, value, fromIndex = ary.length - 1) {
      for (let i = fromIndex; i >= 0; i--) {
        if (ary[i] == value) {
          return i
        }
      }
      return -1
    },
    pull: function (ary) {
      let obj = {}
      let aryNew = []

      for (let i = 1; i < arguments.length - 1; i++) {
        obj[ary[i]] = i
      }
      for (let i = 0; i < ary.length - 1; i++) {
        let flog = true
        if (ary[i] in obj) {
          flog = false
        }
        if (flog) {
          aryNew.push(ary[i])
        }
      }
      return aryNew
    },
    pullAll: function (ary1, ary2) {
      let obj = {}
      let aryNew = []

      for (let i = 1; i < ary2.length - 1; i++) {
        obj[ary1[i]] = i
      }
      for (let i = 0; i < ary1.length - 1; i++) {
        let flog = true
        if (ary1[i] in obj) {
          flog = false
        }
        if (flog) {
          aryNew.push(ary1[i])
        }
      }
      return aryNew
    },
    pullAt: function (ary) {
      let aryNew = []
      for (let i = 0; i < ary.length; i++) {
        for (let j = 1; j < arguments.length; j++) {
          if (i == arguments[j]) {
            aryNew.push(ary[i])
          }
        }
      }
      tyulei.pullAll(ary, aryNew)

      return aryNew
    },
    sortIndexOf: function (ary, value) {
      for (let i = 0; i < ary.length; i++) {
        if (ary[i] == value && ary[i + 1] !== value) {
          return i
        }
      }
      return -1
    },
    takeRight: function (ary, number = 1) {
      let aryNew = []
      for (let i = ary.length - number; i < ary.length; i--) {
        aryNew.push(ary[i])
      }
      return aryNew
    },
    nuiq: function (ary) {
      let obj = {}
      let aryNew = []
      for (let i = 0; i < ary.length; i++) {
        if (obj[ary[i]] == undefined) {
          aryNew.push(ary[i])
          obj[ary[i]] = i
        }
      }
      return aryNew
    },
    unzip: function (ary) {
      let aryNew = []
      let length = []
      //找出输入二维数组中的最长数组
      for (let i = 0; i < ary.length; i++) {
        length.push(ary[i].length)
      }
      //创建一个新的空的二维数组
      for (let i = 0; i < Math.max(...length); i++) {
        aryNew.push([])
      }
      //把原来的二维数组里的值按顺序装到新的数组
      for (let i = 0; i < aryNew.length; i++) {
        for (let j = 0; j < ary.length; j++) {
          aryNew[i].push(ary[j][i])
        }
      }
      return aryNew
    },
    without: function (ary, values) {
      let obj = {}
      let aryNew = []
      for (let i = 1; i < arguments.length; i++) {
        obj[arguments[i]] = i
      }
      for (let i = 0; i < ary.length; i++) {
        if (obj[ary[i]] == undefined) {
          aryNew.push(ary[i])
        }
      }
      return aryNew
    },
    xor: function (arys) {
      let obj = {}
      let aryNew = []
      for (let i = 0; i < arguments.length; i++) {
        for (let j = 0; j < arguments[i].length; j++) {
          if (obj[arguments[i][j]] == undefined) {
            aryNew.push(arguments[i][j])
          }
          obj[arguments[i][j]] = i
        }
      }
      return aryNew
    },
    defaults: function (obj) {
      let objNew = {}
      for (let i = 0; i < arguments.length; i++) {
        for (var prop in arguments[i]) {
          if (objNew[prop] == undefined) {
            objNew[prop] = arguments[i][prop]
          }
        }
      }
      return objNew
    },
    omit: function (obj, props) {
      let objNew = {}
      for (let i = 0; i < props.length; i++) {
        for (let prop in obj) {
          if (prop !== props[i]) {
            objNew[prop] = obj[prop]
          }
        }
      }
      return objNew
    }



  }
</script>

<body>
  <em>
    chunk,compact
    concat
    difference
    drop
    fill
    find
    first/head
    flatten
    indexOf
    initial
    intersection
    join
    last
    lastIndexOf
    nth
    pull
    pullAll
    pullAt
    remove
    reverse
    slice
    sortedIndex
    sortedIndexOf
    tail
    take
    takeRight
    union
    uniq
    unzip
    without
    xor
    zip
    zipObject

    includes
    sample
    sampleSize
    shuffle
    size

    eq,gt,gte
    lt,lte
    add,ceil
    divide
    floor
    max
    mean
    min

    multiply
    round
    substract
    sum
    at
    defaults

    get
    set
    has
    hasIn
    invert
    keys
    assign
    omit
    pick
    values
    camelCase
    capitalize
    deburr

    endsWith
    escape
    kebabCase
    lowerCase
    lowerFirst
    pad
    padEnd
    padStart
    parseInt
    repeat
    replace
    snakeCase
    split
    startCase
    startsWith
    trim
    trimEnd
    trimStart
    truncate
    unescape
    upperCase
    upperFirst
    words
    range
  </em>
</body>

</html>